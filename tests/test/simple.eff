external ( + ) : int -> int -> int = "+";;

external ( - ) : int -> int -> int = "-";;

(* 3;; *)

(* (fun x -> x) ;; *)

(* (fun x -> true) ;; *)

(* (fun x -> x x);; *)

(* (fun x -> x) 3;; *)

(* (fun (x,y) -> 3);; *)

(* if true then 1 else 2;; *)

(* (fun a -> if a then 1 else 2);; *)

(* (fun b -> b);; *)

(* (fun b -> if true then b else b);; *)

effect Op : unit -> int;;

effect Op2 : unit -> int;;

effect Op3 : unit -> int;;

(* (fun x -> #Op ()) true;; *)

(* #Op;; *)

(* #Op ();; *)

(* (fun a -> if a then true else 2);; *)

(* (fun a -> if true then true else 2);; *)

(* (fun v -> if true then v else true);; *)

(* (fun a -> match a with
          | true -> #Op ()
          | false -> #Op2 ()
  );; *)

(* (fun x -> (fun y -> (x, y)));; *)

(* fun f x -> f (f x);; *)

(* handler
  | #Op () k ->  k 3;; *)

(* #type handle (#Op3 ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k 3 *)

(* #Op3 ;; *)

(* #Op3 () ;;  *)

(* let x = fun y -> y in x true;; *)

(* let x = 3 in x;; *)

(* let (x, y) = (1, 2) in x;; *)

(* let x = 1 and y = 2 in x + y;; *)

(* let x = (fun y -> y) in (x true, x 2);; *)

(* let id x = x;; *)

(* let id x = x;;

id 3;;

fun () -> #Op ();;

id (fun () -> #Op ());;

let h = handler
  | #Op () k -> k 3;;


let h2 = handler
  | #Op2 () k -> k 3;;

let r = with h2 handle (with h handle (#Op2 ()));;

let rec check n =
  begin match n with
  | 1 -> 1
  | _ -> n + check (n - 1)
  end *)

(* handle 3 with
  | #Op () k -> k 3
  ;; *)

(* handle (#Op3 ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k 3;; *)


(* fun f -> f 1;; *)

(* fun f x -> f x;; *)

fun f x -> f (f x);;

(* let t2 = (fun x -> x) 1;; *)
(* let id x = x;; *)

(* (fun f x -> f x);; *)

(* (fun f x -> 
  let y = f x in 
  y
);; *)

(fun x -> 
  let y = x in 
  y
);;

(* (fun x -> 
  let rec check y =
    begin match y with
    | a -> a
    end
  in 
  check x
);;
   *)

(* let y = id 1 in y *)