external ( + ) : int -> int -> int = "+";;

external ( - ) : int -> int -> int = "-";;

(* 3;; *)

(* (fun x -> x) ;; *)

(* (fun x -> true) ;; *)

(* (fun x -> x x);; *)

(* (fun x -> x) 3;; *)

(* (fun (x,y) -> 3);; *)

(* if true then 1 else 2;; *)

(* (fun a -> if a then 1 else 2);; *)

(* (fun b -> b);; *)

(* (fun b -> if true then b else b);; *)

effect Op : unit -> int;;

effect Op2 : unit -> bool;;

effect Op3 : unit -> int;;

(* (fun x -> #Op ()) true;; *)

(* #Op;; *)

(* #Op ();; *)

(* (fun a -> if a then true else 2);; *)

(* (fun a -> if true then true else 2);; *)

(* (fun v -> if true then v else true);; *)

(* (fun a -> match a with
          | true -> #Op ()
          | false -> #Op2 ()
  );; *)

(* (fun x -> (fun y -> (x, y)));; *)

(* fun f x -> f (f x);; *)

(* handler
  | #Op () k ->  k 3;; *)

(* #type handle (#Op3 ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k 3 *)

(* #Op3 ;; *)

(* #Op3 () ;;  *)

(* let x = fun y -> y in x true;; *)

(* let x = 3 in x;; *)

(* let (x, y) = (1, 2) in x;; *)

(* let x = 1 and y = 2 in x + y;; *)

(* let x = (fun y -> y) in (x true, x 2);; *)

(* let id x = x;; *)

(* let id x = x;;

id 3;;

fun () -> #Op ();;

id (fun () -> #Op ());;

let h = handler
  | #Op () k -> k 3;;


let h2 = handler
  | #Op2 () k -> k 3;;

let r = with h2 handle (with h handle (#Op2 ()));;

let rec check n =
  begin match n with
  | 1 -> 1
  | _ -> n + check (n - 1)
  end *)

(* handle 3 with
  | #Op () k -> k 3
  ;; *)

(* handle (#Op3 ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k 3;; *)


(* fun f -> f 1;; *)

(* fun f x -> f x;; *)

(* fun f x -> f (f x);; *)
(*
- : () |- ((((τ₁ ⊓ (τ₂ ⊔ τ₃) -(δ₁)→ τ₄) ⊓
             τ₄ -(δ₂)→ τ₅) ⊓
            τ₂ -(δ₃)→ τ₆) -(⊥)→
           τ₂ -(δ₂)→ τ₅) ! (⊥) | [ ; ] = <fun>

- : () |- ((τ₁ ⊔ τ₂ -(δ₁)→ τ₂ ⊓ τ₃) -(⊥)→
           τ₁ -(δ₂)→ τ₃) ! (⊥) | [ ; ] = <fun>
*)

(* let t2 = (fun x -> x) 1;; *)
(* let id x = x;; *)

(* let x = (fun f x -> f (f x));; *)
(* x (fun x -> #Op ()) ;; *)

(* (fun f x -> 
  let y = f x in 
  y
);; *)

(* (fun x -> 
  let y = x in 
  y
);; *)

(* (fun x -> 
  let rec check y =
    begin match y with
    | a -> a
    end
  in 
  check x
);;
   *)

(* let y = id 1 in y *)

(* let select p v d = 
  if (p v) then 
    (v, #Op ())
  else 
    (d, #Op2 ())
  
;; *)
(*
val select : () |- (((τ₁ ⊓ (τ₂ ⊔ τ₃) -(δ₁)→ τ₄ ⊓ bool) ⊓
                     τ₂ -(δ₂)→ τ₅) -(⊥)→
                    τ₂ -(⊥)→
                    τ₆ -(δ₃)→
                    (τ₇ ⊔ τ₆ × (τ₈ ⊔ bool)) ⊔
                    τ₂ × (τ₉ ⊔ int)) | [ ; ] = <fun>

val select : () |- ((τ₁ -(δ₁)→ bool) -(⊥)→
                    τ₁ -(⊥)→
                    τ₂ -(δ₂)→
                    (τ₂ × bool) ⊔
                    (τ₁ × int)) | [ ; ] = <fun>

*)

(* fun () -> #Op ();; *)
(* 
- : () |- (unit -(δ₂ ⊔ δ₁ ⊔ Op)→ τ₁ ⊔ int) ! (⊥) | [ ; ] = <fun> 

- : () |- (unit -(Op)→ int) ! (⊥) | [ ; ] = <fun>
*)

(* fun a -> #Op (); a;; *)
(* fun a -> let b = #Op () in a;; *)

(*
- : () |- (τ₁ -(⊥)→ τ₁) ! (⊥) | [ ; ] = <fun>
*)

(* let sel p v d = 
  if (p v) then 
    #Op ()
  else 
    #Op2 ();; *)

(* fun p q -> if p then q else q *)

(* [1];; *)

(* let rec range m n =
  if m > n then []
  else
    let r = range (m + 1) n in
    m :: r
;; *)

(* let id x = #Op ();x;; *)

(* handle 3 with
  | #Op () k -> k 3
  ;; *)

(* let h2 = handler
  | #Op () k ->  k 3
  | #Op2 () k -> k true;; *)

let h = handler
  | #Op () k ->  k 3
  | #Op2 () k ->  k true;;

(* fun () -> with h handle (#Op3 (); #Op2 ());; *)

handle (#Op ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k true;;

if true then
    1
else
    2+1
;;

#Op2 (); #Op3 () (* doesnt work *)
;;

handle (#Op2 (); #Op3 ()) with
  | #Op () k ->  k 3
  | #Op2 () k ->  k true;;

let x = (fun y -> with y handle (#Op2 ()));;

x h;;

with h handle (#Op2 ());;