effect A : unit -> unit
effect B : unit -> int

effect C : float -> float

let a u () = 
  let comp f h g x = 
    if u x then
      f (g x)
    else 
      h (g x)
  in
  let f x = 
    perform (A ());
    (0, x)
  in
  let h x = 
    let b = perform (B ()) in
    (b, x)
  in
  handle (
    (* this fails if 1 is not applied *)
    comp f h (fun z -> z) 0
  )
  with
  | x -> x
  | effect (A ()) k -> k ()
  | effect (B ()) k -> k 100 