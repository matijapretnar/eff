(* Check every thing in the standard library. *)

(1 < 2);;

(true < false);;

((1,true) < (0,false));;

(* More comprehensive checking of < can be found in test_less_than.eff *)

(1 = 1);;

(1.0 = 1.0);;

(* More comprehensive checking of = can be found in test_equality.eff *)

assert ("a" = "a");;

assert (1.0 /. 0.0 = infinity);;

assert (-. 1.0 /. 0.0 = neg_infinity);;

assert (0.0 /. 0.0 = nan);;

(~-1);;

(~-. 3.14159);;

(~-. 1.0);;

(2 + 2);;

(2 * 2);;

(2 ** 3);;

(42 - 23);;

(42 - ~-23);;

(5 mod 3);;

(0 mod 1);;

check (0 mod 0);;

check (1 mod 0);;

(3.14 +. 2.7);;

(3.14 *. 2.7);;

(3.14 -. 2.7);;

(3.14 /. 2.7);;

(1.0 /. 0.0);;

(100 / 3);;

check (1 / 0);;

(0 / 1);;

check (0 / 0);;

("cherry" ^ "pie");;

(string_of_float 12.);;

(string_of_float 12.0);;

(string_of_float (-12.000009));;

(string_of_int 0);;

(string_of_int (-18));;

(to_string 13);;

(to_string [1,2,3]);;

(to_string (1,2,3));;

(to_string (fun x -> x));;

(int_of_float (-1.5));;

(int_of_float (12.0001));;

(float_of_int 42);;

None;;

(Some 3);;

(ignore (2 + 3));;

(not true);;

(3 > 2);;

("foo" > "bar");;

(1 <= 1);;

(2 >= 1);;

(2 <> 3);;

(range 4 9);;

(map (fun x -> x * x) [1;2;3;4;5]);;

(take (fun k -> 3 * k + 2) 20);;

(fold_left (fun a y -> 2 * a + y) 1 [1;2;3;4;5]);;

(fold_right (fun y a -> 2 * a + y) [1;2;3;4;5] 1);;

(fun k -> check ("iter " ^ to_string k)) [1;2;3;4;5];;

(forall (fun k -> k mod 3 = 2) [1;2;3;4;5]);;

(exists (fun k -> k mod 3 = 2) [1;2;3;4;5]);;

(mem "foo" ["bar"; "baz"]);;

(filter (fun k -> k > 3) [1;2;3;4;5]);;

(complement [1; 2; 3; 4; 5; 6] [2; 4; 8]);;

(intersection [1; 2; 3; 4; 5; 6] [2; 4; 8]);;

(zip [1;2;3] ["a"; "b"; "c"]);;

check (zip [1;2;3;4;5;6] ["a"; "b"; "c"]);;

(unzip [(1, "a"); (2, "b"); (3, "c")]);;

reverse [1;2;3;4;5];;

([1;2;3] @ [4;5;6]);;

(length [1;2;3;4;5]);;

(hd [1;2;3;4]);;

check (hd []);;

(tl [1;2;3;4]);;

check (tl []);;

(abs 5, abs (~-5), abs(-5));;

(min 1 2);;

(max 1 2);;

(gcd 12 8);;

(lcm 12 8);;

(odd 42);;

(even 42);;

(id 5);;

(id id);;

(compose (fun k -> k * k) (fun j -> j +4) 10);;

3 |> (fun x -> x) |> (+) 4;; 

(fst ("foo", 4));;

(snd ("foo", 4));;

check (perform (Print "Does this work?"));;

check (print "How about now?");;

check (print 12);;

check (perform Read);;

(* check (failwith "The cows are home.");;

check (rnd#int 42);;

check (rnd#float 42.0);;

let test_state =
  (let r = new ref in 
   with state r 10 handle
     r := !r + 32;
     !r);; 

(let r = ref 5 in r := !r + 10; !r);;
 *)