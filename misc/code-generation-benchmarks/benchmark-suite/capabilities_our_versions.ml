(*  Code generated by capabilities *)

(* Range *)

(*

Get : Effect
Get = Operation Unit Int


handledGenList : Exp (Int -> Eff [] ((List Int)))
handledGenList = lam1 (\n => withTry1
  Get (\unt => \k => do
      call k 42
    ) (\get => do
      let genList = letrec11 (\get => \genList => \x => do
        if (x == 0) { do
          pure {rs=[ (List Int)]} []
        } else { do
          g <- call get Unit
          y <- app1 genList (x-1)
          -- let a = g :: y
          pure (Cons g y)
        })
      app11 genList get n))

rangeBenchmark : Exp (Int -> Eff [] ( (List Int)))
rangeBenchmark = lam1 (\n =>
  app1 handledGenList n)

*)

let rangeBenchmark_generated x0 =
  List.length
    ((fun x1 ->
       ((let rec f2 x3 k4 =
           if x3 == 0 then k4 [] else (f2 (x3 - 1)) (fun a5 -> k4 (42 :: a5))
         in
         f2)
          x1) (fun a2 -> a2))
       x0)

(* Interp *)

type term =
  | Num of int
  | Add of term * term
  | Mul of term * term
  | Sub of term * term
  | Div of term * term

let addCase =
  Add
    ( Add (Add (Num 20, Num 2), Mul (Num 1, Num 2)),
      Sub (Add (Num 2, Num 2), Div (Num 1, Num 10)) )

let rec createZeroCase n =
  match n with
  | 0 -> Sub (addCase, addCase)
  | n -> Sub (createZeroCase (n - 1), createZeroCase (n - 1))

let rec createCase n =
  match n with
  | 1 -> Div (Num 100, createZeroCase 3)
  | _ -> Add (addCase, createCase (n - 1))

(* exception *)

(* original *)
(*
let interpException_generated  = (fun x0 -> (((let rec f1 x2 = (fun k3 -> (if (custom_isNumber x2) then (k3 (custom_extractNumber x2)) else (if (custom_isDivision x2) then ((f1 (custom_unpackInterNodeRight x2)) (fun a4 -> ((f1 (custom_unpackInterNodeLeft x2)) (fun a5 -> (if (a4 == 0) then -1 else (k3 (int_div a5 a4))))))) else ((f1 (custom_unpackInterNodeLeft x2)) (fun a4 -> ((f1 (custom_unpackInterNodeRight x2)) (fun a5 -> (k3 (a4 + a5))))))))) in f1) x0) (fun a1 -> a1)))
*)

let interpException_generated x0 =
  ((let rec f1 x2 k3 =
      match x2 with
      | Num number -> k3 number
      | Add (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 + a5)))
      | Mul (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 * a5)))
      | Sub (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 - a5)))
      | Div (l, r) ->
          (f1 r) (fun a4 ->
              (f1 l) (fun a5 -> if a4 == 0 then -1 else k3 (a5 / a4)))
    in
    f1)
     x0) (fun a1 -> a1)

let bigTestLoop num =
  let interpException_generated x0 =
    ((let rec f1 x2 k3 =
        match x2 with
        | Num number -> k3 number
        | Add (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 + a5)))
        | Mul (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 * a5)))
        | Sub (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 - a5)))
        | Div (l, r) ->
            (f1 r) (fun a4 ->
                (f1 l) (fun a5 -> if a4 == 0 then -1 else k3 (a5 / a4)))
      in
      f1)
       x0) (fun a1 -> a1)
  in
  let ___finalCase = createCase num in
  let rec looper k s =
    if k = 0 then s
    else looper (k - 1) (s + interpException_generated ___finalCase)
  in
  looper 100 0

(* state *)

(* original *)
(*
let interpState_generated  = (fun x0 -> ((fun x1 -> (let x2 = (((let rec f3 x4 = (fun k5 -> (if (custom_isNumber x4) then (fun x6 -> (let x7 = (k5 (custom_extractNumber x4)) in (x7 ((custom_extractNumber x4) * (custom_extractNumber x4))))) else (if (custom_isDivision x4) then ((f3 (custom_unpackInterNodeRight x4)) (fun a6 -> ((f3 (custom_unpackInterNodeLeft x4)) (fun a7 -> (if (a6 == 0) then (fun x8 -> (let x9 = (k5 x8) in (x9 x8))) else (k5 (int_div a7 a6))))))) else ((f3 (custom_unpackInterNodeLeft x4)) (fun a6 -> ((f3 (custom_unpackInterNodeRight x4)) (fun a7 -> (k5 (a6 + a7))))))))) in f3) x1) (fun a3 -> (fun x4 -> a3))) in (x2 100))) x0))
*)

let testStateLoop n =
  let addCase =
    Add
      ( Add (Add (Num 20, Num 2), Mul (Num 1, Num 2)),
        Sub (Add (Num 2, Num 2), Div (Num 1, Num 10)) )
  in
  let rec createZeroCase n =
    match n with
    | 0 -> Sub (addCase, addCase)
    | n -> Sub (createZeroCase (n - 1), createZeroCase (n - 1))
  in
  let rec createCase n =
    match n with
    | 1 -> Div (Num 100, createZeroCase 3)
    | _ -> Add (addCase, createCase (n - 1))
  in
  (* Fixed a bit by hand *)
  let interpState_generated x0 =
    (fun x1 ->
      let x2 =
        ((let rec f3 x4 k5 =
            match x4 with
            | Num number ->
                fun x6 ->
                  let x7 = k5 number in
                  x7 (number * number)
            | Add (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 + a7)))
            | Mul (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 * a7)))
            | Sub (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 - a7)))
            | Div (l, r) ->
                (f3 r) (fun a6 ->
                    (f3 l) (fun a7 ->
                        if a6 == 0 then fun x8 ->
                          let x9 = k5 x8 in
                          x9 x8
                        else k5 (a7 / a6)))
          in
          f3)
           x1) (fun a3 x4 -> a3)
      in
      x2 0)
      x0
  in
  let ___finalCase = createCase n in
  let rec looper k s =
    if k = 0 then s
    else
      let x = interpState_generated ___finalCase in
      looper (k - 1) (s + x)
  in
  looper 100 0

(*
# testStateLoop 100;;
- : int = 1277200

*)

(* Tree *)

type tree = EmptyNode | Node of tree * int * tree

let tester k =
  let leaf a = Node (EmptyNode, a * k, EmptyNode) in
  let bot t t2 =
    Node
      ( Node (Node (t, 0, t2), 2, leaf 13),
        5,
        Node (leaf 9, 7, Node (t2, 3, Node (leaf 3, 5, t2))) )
  in
  let n1 = Node (bot (leaf 3) (leaf 4), 10, bot (leaf 1) (leaf 3)) in
  let n2 =
    bot (Node (bot (leaf 3) (leaf 4), 10, bot (leaf 1) (leaf 3))) (leaf 10)
  in
  bot n1 n2

let op x y = x - (3 * y)

(* general  *)

let exploreGeneralTree_generated x0 =
  (fun x1 ->
    ((let rec f2 x3 k4 =
        match x3 with
        | EmptyNode -> k4 0
        | Node (l, mid, r) ->
            let x5 = (f2 l) (fun a6 -> k4 (op mid a6)) in
            let x6 = (f2 r) (fun a7 -> k4 (op mid a7)) in
            List.append x5 x6
      in
      f2)
       x1) (fun a2 -> [ a2 ]))
    x0

let test_general_loop n =
  let t = tester n in
  let rec looper k s =
    if k = 0 then s
    else
      looper (k - 1) (s + List.fold_left max 0 (exploreGeneralTree_generated t))
  in
  looper 100 0

(*
# test_general_loop 100;;
- : int = 21174076100

*)

(* leaf state *)

let exploreLeafStateTree_generated leafs x0 =
  (fun x1 ->
    let x2 =
      (((let rec f3 x4 k5 k6 =
           match x4 with
           | EmptyNode ->
               fun x7 ->
                 let x8 = (k5 (List.hd x7)) k6 in
                 x8 (List.tl x7)
           | Node (l, mid, r) ->
               ((f3 l) (fun a7 k8 -> (k5 (op mid a7)) k8)) (fun a7 ->
                   ((f3 r) (fun a8 k9 -> (k5 (op mid a8)) k9)) (fun a8 ->
                       k6 (List.append a7 a8)))
         in
         f3)
          x1) (fun a3 k4 -> k4 [ a3 ])) (fun a3 x4 -> a3)
    in
    x2 leafs)
    x0

let test_leaf_state m =
  let t = tester m in
  let leafs = List.init 154 (fun i -> i * 3) in
  let rec looper k s =
    if k = 0 then s
    else
      looper (k - 1)
        (s + List.fold_left max 0 (exploreLeafStateTree_generated leafs t))
  in
  looper 100 0

(*

   # test_leaf_state 100;;
   - : int = 18792433100
*)

(* leaf update *)

let exploreLeafStateUpdateTree_generated x0 =
  (fun x1 ->
    let x2 =
      (((let rec f3 x4 k5 k6 =
           match x4 with
           | EmptyNode ->
               fun x7 ->
                 let x8 = (k5 x7) k6 in
                 x8 x7
           | Node (l, mid, r) ->
               fun x7 ->
                 let x8 =
                   ((f3 l) (fun a9 k10 -> (k5 (op mid a9)) k10)) (fun a9 ->
                       ((f3 r) (fun a10 k11 -> (k5 (op mid a10)) k11))
                         (fun a10 -> k6 (List.append a9 a10)))
                 in
                 x8 (mid * mid)
         in
         f3)
          x1) (fun a3 k4 -> k4 [ a3 ])) (fun a3 x4 -> a3)
    in
    x2 (-1))
    x0

let test_leaf_state_update m =
  let t = tester m in
  let rec looper k s =
    if k = 0 then s
    else
      looper (k - 1)
        (s + List.fold_left max 0 (exploreLeafStateUpdateTree_generated t))
  in
  looper 100 0

(*
# test_leaf_state_update 100;;
- : int = 9976723161500
*)

(* queens *)

let no_attack (x, y) (x', y') =
  x <> x' && y <> y' && abs (x - x') <> abs (y - y')

let rec not_attacked x' = function
  | [] -> true
  | x :: xs -> if no_attack x' x then not_attacked x' xs else false

let available number_of_queens x qs =
  let rec loop (possible, y) =
    if y < 1 then possible
    else if not_attacked (x, y) qs then loop (y :: possible, y - 1)
    else loop (possible, y - 1)
  in
  loop ([], number_of_queens)

let queensAll_generated x0 =
  (fun x1 ->
    ((fun x2 k3 ->
       (((let rec f4 x5 y6 k7 =
            if fst x5 > snd x5 then k7 y6
            else
              ((let rec f8 x9 k10 =
                  match x9 with
                  | [] -> []
                  | hhd :: ttl ->
                      let x11 = k10 hhd in
                      let x12 = (f8 ttl) k10 in
                      List.append x11 x12
                in
                f8)
                 (available (snd x5) (fst x5) y6)) (fun a8 ->
                  ((f4 (fst x5 + 1, snd x5)) ((fst x5, a8) :: y6)) k7)
          in
          f4)
           (1, x2))
          [])
         k3)
       x1) (fun a2 -> [ a2 ]))
    x0
