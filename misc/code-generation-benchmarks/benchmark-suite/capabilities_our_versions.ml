(*  Code generated by capabilities *)

(* Range *)

(*

Get : Effect
Get = Operation Unit Int


handledGenList : Exp (Int -> Eff [] ((List Int)))
handledGenList = lam1 (\n => withTry1
  Get (\unt => \k => do
      call k 42
    ) (\get => do
      let genList = letrec11 (\get => \genList => \x => do
        if (x == 0) { do
          pure {rs=[ (List Int)]} []
        } else { do
          g <- call get Unit
          y <- app1 genList (x-1)
          -- let a = g :: y
          pure (Cons g y)
        })
      app11 genList get n))

rangeBenchmark : Exp (Int -> Eff [] ( (List Int)))
rangeBenchmark = lam1 (\n =>
  app1 handledGenList n)

*)

let rangeBenchmark_generated x0 =
  List.length
    ((fun x1 ->
       ((let rec f2 x3 k4 =
           if x3 == 0 then k4 [] else (f2 (x3 - 1)) (fun a5 -> k4 (42 :: a5))
         in
         f2)
          x1) (fun a2 -> a2))
       x0)

(* Interp *)

type term =
  | Num of int
  | Add of term * term
  | Mul of term * term
  | Sub of term * term
  | Div of term * term

let addCase =
  Add
    ( Add (Add (Num 20, Num 2), Mul (Num 1, Num 2)),
      Sub (Add (Num 2, Num 2), Div (Num 1, Num 10)) )

let rec createZeroCase n =
  match n with
  | 0 -> Sub (addCase, addCase)
  | n -> Sub (createZeroCase (n - 1), createZeroCase (n - 1))

let rec createCase n =
  match n with
  | 1 -> Div (Num 100, createZeroCase 3)
  | _ -> Add (addCase, createCase (n - 1))

(* exception *)

(* original *)
(*
let interpException_generated  = (fun x0 -> (((let rec f1 x2 = (fun k3 -> (if (custom_isNumber x2) then (k3 (custom_extractNumber x2)) else (if (custom_isDivision x2) then ((f1 (custom_unpackInterNodeRight x2)) (fun a4 -> ((f1 (custom_unpackInterNodeLeft x2)) (fun a5 -> (if (a4 == 0) then -1 else (k3 (int_div a5 a4))))))) else ((f1 (custom_unpackInterNodeLeft x2)) (fun a4 -> ((f1 (custom_unpackInterNodeRight x2)) (fun a5 -> (k3 (a4 + a5))))))))) in f1) x0) (fun a1 -> a1)))
*)

let interpException_generated x0 =
  ((let rec f1 x2 k3 =
      match x2 with
      | Num number -> k3 number
      | Add (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 + a5)))
      | Mul (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 * a5)))
      | Sub (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 - a5)))
      | Div (l, r) ->
          (f1 r) (fun a4 ->
              (f1 l) (fun a5 -> if a4 == 0 then -1 else k3 (a5 / a4)))
    in
    f1)
     x0) (fun a1 -> a1)

let bigTestLoop num =
  let interpException_generated x0 =
    ((let rec f1 x2 k3 =
        match x2 with
        | Num number -> k3 number
        | Add (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 + a5)))
        | Mul (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 * a5)))
        | Sub (l, r) -> (f1 l) (fun a4 -> (f1 r) (fun a5 -> k3 (a4 - a5)))
        | Div (l, r) ->
            (f1 r) (fun a4 ->
                (f1 l) (fun a5 -> if a4 == 0 then -1 else k3 (a5 / a4)))
      in
      f1)
       x0) (fun a1 -> a1)
  in
  let ___finalCase = createCase num in
  let rec looper k s =
    if k = 0 then s
    else looper (k - 1) (s + interpException_generated ___finalCase)
  in
  looper 100 0

(* state *)

(* original *)
(*
let interpState_generated  = (fun x0 -> ((fun x1 -> (let x2 = (((let rec f3 x4 = (fun k5 -> (if (custom_isNumber x4) then (fun x6 -> (let x7 = (k5 (custom_extractNumber x4)) in (x7 ((custom_extractNumber x4) * (custom_extractNumber x4))))) else (if (custom_isDivision x4) then ((f3 (custom_unpackInterNodeRight x4)) (fun a6 -> ((f3 (custom_unpackInterNodeLeft x4)) (fun a7 -> (if (a6 == 0) then (fun x8 -> (let x9 = (k5 x8) in (x9 x8))) else (k5 (int_div a7 a6))))))) else ((f3 (custom_unpackInterNodeLeft x4)) (fun a6 -> ((f3 (custom_unpackInterNodeRight x4)) (fun a7 -> (k5 (a6 + a7))))))))) in f3) x1) (fun a3 -> (fun x4 -> a3))) in (x2 100))) x0))
*)

let testStateLoop n =
  let addCase =
    Add
      ( Add (Add (Num 20, Num 2), Mul (Num 1, Num 2)),
        Sub (Add (Num 2, Num 2), Div (Num 1, Num 10)) )
  in
  let rec createZeroCase n =
    match n with
    | 0 -> Sub (addCase, addCase)
    | n -> Sub (createZeroCase (n - 1), createZeroCase (n - 1))
  in
  let rec createCase n =
    match n with
    | 1 -> Div (Num 100, createZeroCase 3)
    | _ -> Add (addCase, createCase (n - 1))
  in
  (* Fixed a bit by hand *)
  let interpState_generated x0 =
    (fun x1 ->
      let x2 =
        ((let rec f3 x4 k5 =
            match x4 with
            | Num number ->
                fun x6 ->
                  let x7 = k5 number in
                  x7 (number * number)
            | Add (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 + a7)))
            | Mul (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 * a7)))
            | Sub (l, r) -> (f3 l) (fun a6 -> (f3 r) (fun a7 -> k5 (a6 - a7)))
            | Div (l, r) ->
                (f3 r) (fun a6 ->
                    (f3 l) (fun a7 ->
                        if a6 == 0 then fun x8 ->
                          let x9 = k5 x8 in
                          x9 x8
                        else k5 (a7 / a6)))
          in
          f3)
           x1) (fun a3 x4 -> a3)
      in
      x2 0)
      x0
  in
  let ___finalCase = createCase n in
  let rec looper k s =
    if k = 0 then s
    else
      let x = interpState_generated ___finalCase in
      looper (k - 1) (s + x)
  in
  looper 100 0

(*
# testStateLoop 100;;
- : int = 1277200

*)

(* Tree *)

type tree = EmptyNode | Node of tree * int * tree
