(* A n-queens implementation without top-level bindings and no polymorphism *)

(*external ( <> ) : int -> int -> bool = "<>"*)
external ( < ) : int -> int -> bool = "<"
external ( = ) : int -> int -> bool = "="
(*external ( > ) : int -> int -> bool = ">"*)
external ( - ) : int -> int -> int = "-"
external ( + ) : int -> int -> int = "+"
external ( ~- ) : int -> int = "~-"



effect Decide : unit -> bool
effect Fail : unit -> empty

(*type 'a option = None | Some of 'a;; *)
type inttuple = IntTuple of int * int;;
type intlist = IntNil | IntCons of int * intlist;;
type inttuplist = IntTupNil | IntTupCons of inttuple * inttuplist;;
type void = Void;;

let test_queens n = 
  let absurd void = (match void with)
  in

(*  let rec (@) xs ys = *)
(*    match xs with *)
(*    | [] -> ys *)
(*    | x :: xs -> x :: (xs @ ys) *)
(*  in *)

  let (>) x y = y < x
  in
  let (<>) x y = if (y = x) then false else true
  in
  let abs x = if x < 0 then -x else x
  in

  let no_attack q1 q2 = (
      match q1 with
      | IntTuple (x, y) -> (
          match q2 with
          | IntTuple (x', y') ->
              x <> x' && y <> y' && abs (x - x') <> abs (y - y')
          )
      )
  in
  let rec not_attacked x' qs =
    match qs with
    | IntTupNil -> true
    | IntTupCons (x, xs) -> if no_attack x' x then not_attacked x' xs else false
  in

  let available number_of_queens x qs =
    let rec loop possible y =
      if y < 1 then
        possible
      else if not_attacked (IntTuple (x, y)) qs then
        loop (IntCons (y, possible)) (y - 1)
      else
        loop possible (y - 1)
    in
    loop IntNil number_of_queens
  in

  let rec choose xs = match xs with
    | IntNil -> (match (perform (Fail ())) with)
    | IntCons (x, xs') -> if perform (Decide ()) then x else choose xs'
  in

(*  let optionalize = handler *)
(*    | effect (Decide _) k -> ( *)
(*            match k true with *)
(*                  | Some x -> Some x *)
(*                  | None -> k false *)
(*            ) *)
(*    | effect (Fail _) _k -> None *)
(*    | y -> (Some y) *)
(*  in *)

  let backtrack = handler
    | effect (Decide _) k ->
            (fun kf ->
                  k true (fun _ -> k false kf) )  
    | effect (Fail _) _k -> (fun kf -> kf ())
    | y -> (fun _ -> y)
  in

(*  let choose_all = handler *)
(*    | effect (Decide _) k -> k true @ k false *)
(*    | effect (Fail _) _k -> [] *)
(*    | x -> [x] *)
(*  in *)

  let queens number_of_queens =
    let rec place x qs =
      if x > number_of_queens then qs else
        let y = choose (available number_of_queens x qs) in
        place (x + 1) (IntTupCons (IntTuple (x, y), qs))
    in
    place 1 IntTupNil
  in

(*  let queens_one_option number_of_queens = *)
(*    with optionalize handle queens number_of_queens *)
(*  in *)
  let queens_one_cps number_of_queens =
    (with backtrack handle queens number_of_queens) (fun () -> (absurd (perform (Fail ()))))
  in
(*  let queens_all number_of_queens = *)
(*    with choose_all handle queens number_of_queens *)
(*  in *)
  queens_one_cps n
in test_queens 8
