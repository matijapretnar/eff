effect Decide : unit -> bool;;
effect Fail : unit -> empty;;

let rec choose =
  function
  | [] -> absurd (#Fail ())
  | x::xs -> if #Decide () then x else choose xs

let backtrack = handler
| #Decide () k ->
    handle k true with
    | #Fail () _ -> k false

let choose_all =
    handler
    | val x -> [x]
    | #Decide () k -> k true @ k false
    | #Fail _ _ -> []

;;

let no_attack (x,y) (x',y') =
  x <> x' && y <> y' && abs (x - x') <> abs (y - y');;

let available number_of_queens x qs =
  let rec loop possible y =
    if y < 1 then possible else
    if forall (no_attack (x, y)) qs then loop (y :: possible) (y - 1) else loop possible (y - 1)
  in
  loop [] number_of_queens
;;

let queens n =
  let rec place x qs =
    if x > n then qs else
      let y = choose (available n x qs) in
      place (x+1) ((x, y) :: qs)
  in place 1 []


(* This one finds [(8, 4); (7, 2); (6, 7); (5, 3); (4, 6); (3, 8); (2, 5); (1, 1)]. *)
let find_one n =
  with backtrack handle queens n
;;

(* This one finds all the solutions. *)
let find_all n =
  with choose_all handle queens n
;;
